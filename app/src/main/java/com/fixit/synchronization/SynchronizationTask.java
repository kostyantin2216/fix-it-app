package com.fixit.synchronization;

import android.content.Context;
import android.os.Process;

import com.fixit.data.DataModelObject;
import com.fixit.data.JobReason;
import com.fixit.data.Profession;
import com.fixit.database.CommonDAO;
import com.fixit.factories.DAOFactory;
import com.fixit.rest.ServerCallback;
import com.fixit.rest.apis.SynchronizationServiceAPI;
import com.fixit.rest.requests.data.SynchronizationRequestData;
import com.fixit.rest.responses.APIResponse;
import com.fixit.rest.responses.APIResponseHeader;
import com.fixit.rest.responses.data.SynchronizationResponseData;
import com.fixit.utils.CommonUtils;
import com.fixit.utils.Constants;
import com.fixit.utils.FILog;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Set;

import retrofit2.Response;

/**
 * Created by Kostyantin on 3/27/2017.
 *
 * if this task is stopped it will only prevent calls to SynchronizationCallback, it
 * will still try to finish synchronization if it already has the response from the server.
 */
public class SynchronizationTask extends Thread {

    private final static String[] SYNCHRONIZATION_TARGETS = new String[] {
            Profession.class.getSimpleName(),
            JobReason.class.getSimpleName()
    };

    private final SynchronizationCallback mCallback;
    private final SynchronizationHistory mHistory;
    private final SynchronizationServiceAPI mServiceApi;
    private final DAOFactory mDaoFactory;

    private volatile boolean mStopped;

    public SynchronizationTask(Context context, SynchronizationServiceAPI api, DAOFactory daoFactory, SynchronizationCallback callback) {
        this.mServiceApi = api;
        this.mCallback = callback;
        this.mDaoFactory = daoFactory;
        this.mHistory = new SynchronizationHistory(context, SYNCHRONIZATION_TARGETS);
    }

    public void stopTask() {
        mStopped = true;
    }

    public boolean isReadyForSynchronization() {
        return mHistory.isReadyForSync;
    }

    @Override
    public void run() {
        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);

        Map<String, Set<SynchronizationAction>> history = mHistory.getHistory();     // create request data and get response body.
        SynchronizationRequestData requestData = new SynchronizationRequestData(mHistory.getLastUpdate(), history);

        FILog.i(Constants.LOG_TAG_SYNCHRONIZATION, "beginning synchronization...");

        if(!mStopped) {
            try {
                Response<APIResponse<SynchronizationResponseData>> response = mServiceApi.synchronize(requestData).execute();

                if (response == null || !response.isSuccessful()) {
                    if (!mStopped) {
                        mCallback.serverUnavailable();
                    }
                } else {
                    APIResponse<SynchronizationResponseData> apiResponse = response.body();
                    // check for errors from server.
                    APIResponseHeader header = apiResponse.getHeader();
                    if (header.hasErrors()) {
                        String error = header.getErrors().get(0).getDescription();
                        FILog.i(Constants.LOG_TAG_SYNCHRONIZATION, "error while synchronizing: " + error);

                        if (!mStopped) {
                            mCallback.onSynchronizationError(error, null);
                        }
                    } else {
                        // no errors, great! let's start synchronizing.
                        SynchronizationResponseData responseData = apiResponse.getData();

                        FILog.i(Constants.LOG_TAG_SYNCHRONIZATION, "synchronizing  " + responseData.getDescription());

                        synchronize(responseData);

                        // update synchronization history for future synchronizations.
                        mHistory.update(responseData.getSynchronizationResults());

                        if (!mStopped) {
                            mCallback.onSynchronizationComplete();
                        }
                    }
                }
            } catch (IOException e) {
                if (!mStopped) {
                    mCallback.onSynchronizationError("Could not connect to server", e);
                }
            }
        }
    }

    /**
     * Synchronize SQLite data with server using the response data from the synchronization request,
     * the response data contains {@link SynchronizationResult} synchronization results which indicate
     * what action needs to be performed and also contains the necessary data that is needed for that
     * action.
     *
     * This method is also in charge of performing the necessary actions provided by the results, .
     *
     * @param responseData response data generated by the server from a synchronization request.
     */
    @SuppressWarnings("unchecked")
    private void synchronize(SynchronizationResponseData responseData) {
        List<SynchronizationResult> syncResults = responseData.getSynchronizationResults();
        for(SynchronizationResult syncResult : syncResults) {
            if(syncResult.isSupported()) {
                CommonDAO<DataModelObject> dao = mDaoFactory.createDaoForDmoName(syncResult.getName());
                if (dao != null) {
                    SynchronizationResult.Result[] results = syncResult.getResults();
                    for (SynchronizationResult.Result result : results) {
                        SynchronizationAction action = result.getAction();
                        switch (action.getActionEnum()) {
                            case OVERRIDE:
                                // FIXME: inserting existing records prints ugly log error messages, for now we truncate before we insert.
                            case INSERT:
                                dao.truncate();
                                dao.insert(result.getData());
                                break;
                            case UPDATE:
                                dao.updateAll(result.getData());
                                break;
                            case DELETE:
                                Set<Long> ids = result.getIds();
                                for (Long id : ids) {
                                    dao.delete(String.valueOf(id));
                                }
                                break;
                        }
                    }
                } else {
                    FILog.e(Constants.LOG_TAG_SYNCHRONIZATION, "missing dao for " + syncResult.getName());
                }
            }
        }
    }

    public interface SynchronizationCallback extends ServerCallback {
        void onSynchronizationComplete();
        void onSynchronizationError(String msg, Throwable t);
    }

}
